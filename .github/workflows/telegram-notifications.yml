name: AImax Telegram通知系統

on:
  schedule:
    # 每小時發送系統狀態摘要
    - cron: '0 * * * *'
  workflow_dispatch:
    inputs:
      notification_type:
        description: '通知類型'
        required: true
        default: 'system_status'
        type: choice
        options:
        - system_status     # 系統狀態
        - trading_summary   # 交易摘要
        - emergency_alert   # 緊急警報
        - test_message      # 測試消息
        - daily_report      # 每日報告
      custom_message:
        description: '自定義消息內容'
        required: false
        type: string

env:
  TELEGRAM_ENABLED: true
  PYTHON_VERSION: '3.10'
  
jobs:
  telegram-notification:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    steps:
    - name: 🔄 檢出代碼
      uses: actions/checkout@v4
      
    - name: 🐍 設置Python環境
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: 📦 安裝通知依賴
      run: |
        python -m pip install --upgrade pip
        pip install requests aiohttp pytz
        
    - name: 📱 發送Telegram通知
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        echo "📱 準備發送Telegram通知..."
        python -c "
        import json
        import os
        import requests
        from datetime import datetime, timedelta
        import pytz
        
        class TelegramNotifier:
            def __init__(self, bot_token, chat_id):
                self.bot_token = bot_token
                self.chat_id = chat_id
                self.base_url = f'https://api.telegram.org/bot{bot_token}'
            
            def send_message(self, message, parse_mode='HTML'):
                try:
                    url = f'{self.base_url}/sendMessage'
                    data = {
                        'chat_id': self.chat_id,
                        'text': message,
                        'parse_mode': parse_mode
                    }
                    
                    response = requests.post(url, data=data, timeout=10)
                    
                    if response.status_code == 200:
                        print('✅ Telegram消息發送成功')
                        return True
                    else:
                        print(f'❌ Telegram消息發送失敗: {response.status_code}')
                        print(f'響應內容: {response.text}')
                        return False
                        
                except Exception as e:
                    print(f'❌ 發送Telegram消息時發生錯誤: {str(e)}')
                    return False
            
            def send_system_status(self):
                taipei_tz = pytz.timezone('Asia/Taipei')
                now_taipei = datetime.now(taipei_tz)
                
                # 讀取系統狀態
                system_data = {}
                try:
                    if os.path.exists('data/states/current_trading_state.json'):
                        with open('data/states/current_trading_state.json', 'r') as f:
                            system_data = json.load(f)
                except:
                    pass
                
                # 讀取今日統計
                today = now_taipei.strftime('%Y-%m-%d')
                daily_stats = {}
                try:
                    stats_file = f'data/analytics/daily_stats_{today}.json'
                    if os.path.exists(stats_file):
                        with open(stats_file, 'r') as f:
                            daily_stats = json.load(f)
                except:
                    pass
                
                # 讀取最新價格
                current_price = 0
                try:
                    if os.path.exists('data/monitoring/last_price.json'):
                        with open('data/monitoring/last_price.json', 'r') as f:
                            price_data = json.load(f)
                            current_price = price_data.get('price', 0)
                except:
                    pass
                
                # 構建狀態消息
                trading_active = system_data.get('trading_status', {}).get('is_active', False)
                executions_today = system_data.get('trading_status', {}).get('total_executions_today', 0)
                strategy = system_data.get('trading_status', {}).get('current_strategy', 'unknown')
                volatility = system_data.get('market_data', {}).get('volatility_level', 'unknown')
                
                status_emoji = '🟢' if trading_active else '🔴'
                
                message = f'''
🤖 <b>AImax 系統狀態報告</b>
                
{status_emoji} <b>交易狀態</b>: {'運行中' if trading_active else '已停止'}
📊 <b>策略</b>: {strategy.replace('_', ' ').title()}
🔄 <b>今日執行</b>: {executions_today} 次
📈 <b>波動性</b>: {volatility.upper()}

💰 <b>當前BTC價格</b>: NT${current_price:,.0f}
🕐 <b>台北時間</b>: {now_taipei.strftime('%Y-%m-%d %H:%M:%S')}

📊 <b>今日統計</b>:
• 總執行: {daily_stats.get('total_executions', 0)} 次
• 高波動: {daily_stats.get('high_volatility_executions', 0)} 次
• 中波動: {daily_stats.get('medium_volatility_executions', 0)} 次
• 低波動: {daily_stats.get('low_volatility_executions', 0)} 次

🎯 <b>平均信心度</b>: {daily_stats.get('average_confidence', 0.85):.0%}
💎 <b>勝率目標</b>: 85%+

☁️ <b>雲端狀態</b>: GitHub Actions 正常
🔄 <b>下次更新</b>: 1小時後

<i>🚀 AImax 智能交易系統 v3.0</i>
                '''.strip()
                
                return self.send_message(message)
            
            def send_trading_summary(self):
                taipei_tz = pytz.timezone('Asia/Taipei')
                now_taipei = datetime.now(taipei_tz)
                today = now_taipei.strftime('%Y-%m-%d')
                
                # 讀取交易執行記錄
                executions = []
                try:
                    exec_file = f'data/trading/execution_log_{today}.jsonl'
                    if os.path.exists(exec_file):
                        with open(exec_file, 'r') as f:
                            for line in f:
                                if line.strip():
                                    executions.append(json.loads(line.strip()))
                except:
                    pass
                
                # 分析執行數據
                total_executions = len(executions)
                high_vol_count = sum(1 for e in executions if e.get('volatility_level') == 'high')
                medium_vol_count = sum(1 for e in executions if e.get('volatility_level') == 'medium')
                low_vol_count = sum(1 for e in executions if e.get('volatility_level') == 'low')
                
                successful_count = sum(1 for e in executions if e.get('status') == 'success')
                win_rate = (successful_count / total_executions * 100) if total_executions > 0 else 0
                
                avg_confidence = sum(e.get('confidence', 0.85) for e in executions) / total_executions if total_executions > 0 else 0.85
                
                message = f'''
📈 <b>AImax 交易執行摘要</b>

📅 <b>日期</b>: {today}
🕐 <b>更新時間</b>: {now_taipei.strftime('%H:%M:%S')}

🔄 <b>執行統計</b>:
• 總執行次數: {total_executions}
• 成功執行: {successful_count}
• 執行成功率: {win_rate:.1f}%

📊 <b>波動性分布</b>:
• 🔥 高波動: {high_vol_count} 次 ({high_vol_count/total_executions*100:.1f}%)
• 📊 中波動: {medium_vol_count} 次 ({medium_vol_count/total_executions*100:.1f}%)
• 📉 低波動: {low_vol_count} 次 ({low_vol_count/total_executions*100:.1f}%)

🎯 <b>策略表現</b>:
• 平均信心度: {avg_confidence:.0%}
• 目標勝率: 85%+
• 當前表現: {'✅ 達標' if win_rate >= 85 else '⚠️ 需優化' if win_rate >= 70 else '❌ 需檢查'}

💡 <b>智能頻率控制</b>: 
{'🔥 高頻模式' if high_vol_count > total_executions * 0.3 else '📊 正常模式'}

<i>🤖 AImax 85%勝率策略運行中</i>
                '''.strip()
                
                return self.send_message(message)
            
            def send_emergency_alert(self, alert_message=''):
                taipei_tz = pytz.timezone('Asia/Taipei')
                now_taipei = datetime.now(taipei_tz)
                
                message = f'''
🚨 <b>AImax 緊急警報</b> 🚨

⚠️ <b>警報類型</b>: 系統異常
🕐 <b>發生時間</b>: {now_taipei.strftime('%Y-%m-%d %H:%M:%S')}

📋 <b>詳細信息</b>:
{alert_message if alert_message else '系統檢測到異常狀況，請檢查交易系統狀態。'}

🔧 <b>建議操作</b>:
1. 檢查GitHub Actions運行狀態
2. 驗證MAX API連接
3. 查看系統監控數據
4. 必要時執行緊急停止

🌐 <b>監控面板</b>: https://winyoulife.github.io/AImax-Trading-System/

<i>⚡ 請立即處理此警報</i>
                '''.strip()
                
                return self.send_message(message)
            
            def send_daily_report(self):
                taipei_tz = pytz.timezone('Asia/Taipei')
                now_taipei = datetime.now(taipei_tz)
                today = now_taipei.strftime('%Y-%m-%d')
                yesterday = (now_taipei - timedelta(days=1)).strftime('%Y-%m-%d')
                
                # 讀取今日和昨日數據進行對比
                today_stats = {}
                yesterday_stats = {}
                
                try:
                    today_file = f'data/analytics/daily_stats_{today}.json'
                    if os.path.exists(today_file):
                        with open(today_file, 'r') as f:
                            today_stats = json.load(f)
                except:
                    pass
                
                try:
                    yesterday_file = f'data/analytics/daily_stats_{yesterday}.json'
                    if os.path.exists(yesterday_file):
                        with open(yesterday_file, 'r') as f:
                            yesterday_stats = json.load(f)
                except:
                    pass
                
                today_executions = today_stats.get('total_executions', 0)
                yesterday_executions = yesterday_stats.get('total_executions', 0)
                execution_change = today_executions - yesterday_executions
                
                today_win_rate = today_stats.get('win_rate', 0) * 100
                yesterday_win_rate = yesterday_stats.get('win_rate', 0) * 100
                win_rate_change = today_win_rate - yesterday_win_rate
                
                message = f'''
📊 <b>AImax 每日交易報告</b>

📅 <b>報告日期</b>: {today}
🕐 <b>生成時間</b>: {now_taipei.strftime('%H:%M:%S')}

📈 <b>今日表現</b>:
• 執行次數: {today_executions} ({'+' if execution_change >= 0 else ''}{execution_change} vs 昨日)
• 勝率: {today_win_rate:.1f}% ({'+' if win_rate_change >= 0 else ''}{win_rate_change:.1f}% vs 昨日)
• 平均信心度: {today_stats.get('average_confidence', 0.85):.0%}

🎯 <b>策略分析</b>:
• 高波動執行: {today_stats.get('high_volatility_executions', 0)} 次
• 智能頻率控制: {'✅ 有效' if today_stats.get('high_volatility_executions', 0) > 0 else '📊 正常'}
• 85%勝率目標: {'🎯 已達成' if today_win_rate >= 85 else '⚠️ 持續優化中'}

💾 <b>系統健康</b>:
• GitHub Actions: ✅ 正常
• 數據存儲: ✅ 正常  
• API連接: ✅ 正常

🔮 <b>明日展望</b>:
• 繼續85%勝率策略
• 智能頻率控制優化
• 系統穩定性提升

<i>🚀 AImax 持續為您創造價值</i>
                '''.strip()
                
                return self.send_message(message)
            
            def send_test_message(self):
                taipei_tz = pytz.timezone('Asia/Taipei')
                now_taipei = datetime.now(taipei_tz)
                
                message = f'''
🧪 <b>AImax Telegram測試</b>

✅ <b>連接狀態</b>: 正常
🤖 <b>機器人</b>: 運行中
📱 <b>通知系統</b>: 已啟用

🕐 <b>測試時間</b>: {now_taipei.strftime('%Y-%m-%d %H:%M:%S')}
☁️ <b>執行環境</b>: GitHub Actions

🎯 <b>功能測試</b>:
• 系統狀態通知 ✅
• 交易摘要通知 ✅  
• 緊急警報通知 ✅
• 每日報告通知 ✅

💡 <b>通知系統已準備就緒！</b>

<i>🔔 AImax 智能通知系統</i>
                '''.strip()
                
                return self.send_message(message)
        
        # 檢查Telegram配置
        bot_token = os.environ.get('TELEGRAM_BOT_TOKEN', '')
        chat_id = os.environ.get('TELEGRAM_CHAT_ID', '')
        
        if not bot_token or not chat_id:
            print('⚠️ Telegram配置未設置，跳過通知')
            print('請在GitHub Secrets中設置 TELEGRAM_BOT_TOKEN 和 TELEGRAM_CHAT_ID')
            exit(0)
        
        # 創建通知器
        notifier = TelegramNotifier(bot_token, chat_id)
        
        # 根據輸入類型發送通知
        notification_type = os.environ.get('INPUT_NOTIFICATION_TYPE', 'system_status')
        custom_message = os.environ.get('INPUT_CUSTOM_MESSAGE', '')
        
        print(f'📱 發送通知類型: {notification_type}')
        
        success = False
        
        if notification_type == 'system_status':
            success = notifier.send_system_status()
        elif notification_type == 'trading_summary':
            success = notifier.send_trading_summary()
        elif notification_type == 'emergency_alert':
            success = notifier.send_emergency_alert(custom_message)
        elif notification_type == 'daily_report':
            success = notifier.send_daily_report()
        elif notification_type == 'test_message':
            success = notifier.send_test_message()
        else:
            print(f'❌ 未知的通知類型: {notification_type}')
            exit(1)
        
        if success:
            print('✅ Telegram通知發送成功')
        else:
            print('❌ Telegram通知發送失敗')
            exit(1)
        "
        
    - name: 📊 記錄通知歷史
      if: always()
      run: |
        echo "📊 記錄Telegram通知歷史..."
        python -c "
        import json
        import os
        from datetime import datetime
        
        # 創建通知記錄
        notification_record = {
            'timestamp': datetime.now().isoformat(),
            'notification_type': os.environ.get('INPUT_NOTIFICATION_TYPE', 'system_status'),
            'custom_message': os.environ.get('INPUT_CUSTOM_MESSAGE', ''),
            'github_run_id': os.environ.get('GITHUB_RUN_ID', 'unknown'),
            'status': 'completed'
        }
        
        # 保存到通知歷史
        os.makedirs('data/notifications', exist_ok=True)
        today = datetime.now().strftime('%Y-%m-%d')
        history_file = f'data/notifications/telegram_history_{today}.jsonl'
        
        with open(history_file, 'a', encoding='utf-8') as f:
            f.write(json.dumps(notification_record, ensure_ascii=False) + '\\n')
        
        # 更新最新通知記錄
        with open('data/notifications/latest_notification.json', 'w', encoding='utf-8') as f:
            json.dump(notification_record, f, indent=2, ensure_ascii=False)
        
        print('📝 通知歷史記錄已保存')
        "
        
    - name: 📤 保存通知數據
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: telegram-notifications-${{ github.run_number }}
        path: data/notifications/
        retention-days: 7