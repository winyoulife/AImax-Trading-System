#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ÂÄâ‰ΩçÁÆ°ÁêÜÂô® - Êô∫ËÉΩÂÄâ‰ΩçÁÆ°ÁêÜÂíåÊ≠¢ÊêçÊ©üÂà∂
"""

import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass
from enum import Enum

logger = logging.getLogger(__name__)

class PositionStatus(Enum):
    """ÂÄâ‰ΩçÁãÄÊÖã"""
    ACTIVE = "active"
    CLOSED = "closed"
    STOPPED = "stopped"

@dataclass
class PositionInfo:
    """ÂÄâ‰Ωç‰ø°ÊÅØ"""
    position_id: str
    symbol: str
    side: str  # BUY/SELL
    quantity: float
    entry_price: float
    current_price: float
    entry_time: datetime
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    trailing_stop: Optional[float] = None
    status: PositionStatus = PositionStatus.ACTIVE
    unrealized_pnl: float = 0.0
    realized_pnl: float = 0.0
    max_profit: float = 0.0
    max_loss: float = 0.0
    ai_decision_id: Optional[str] = None

class PositionManager:
    """ÂÄâ‰ΩçÁÆ°ÁêÜÂô®"""
    
    def __init__(self):
        """ÂàùÂßãÂåñÂÄâ‰ΩçÁÆ°ÁêÜÂô®"""
        self.positions: List[PositionInfo] = []
        self.closed_positions: List[PositionInfo] = []
        
        # ÂÄâ‰ΩçÁÆ°ÁêÜÈÖçÁΩÆ
        self.config = {
            'default_stop_loss': 0.02,      # 2%Ê≠¢Êêç
            'default_take_profit': 0.05,    # 5%Ê≠¢Áõà
            'trailing_stop_ratio': 0.015,   # 1.5%ËøΩËπ§Ê≠¢Êêç
            'max_holding_time': 24,         # ÊúÄÂ§ßÊåÅÂÄâ24Â∞èÊôÇ
            'position_size_limit': 0.05,    # ÂñÆÂÄâ‰ΩçÊúÄÂ§ß5%
            'total_exposure_limit': 0.30    # Á∏ΩÊö¥Èú≤ÊúÄÂ§ß30%
        }
        
        # Áµ±Ë®à‰ø°ÊÅØ
        self.stats = {
            'total_positions': 0,
            'profitable_positions': 0,
            'loss_positions': 0,
            'avg_holding_time': 0.0,
            'avg_profit': 0.0,
            'avg_loss': 0.0,
            'win_rate': 0.0,
            'total_pnl': 0.0
        }
        
        logger.info("üìä ÂÄâ‰ΩçÁÆ°ÁêÜÂô®ÂàùÂßãÂåñÂÆåÊàê")
    
    def create_position(self, trade_result: Dict[str, Any], 
                       ai_decision: Dict[str, Any]) -> PositionInfo:
        """ÂâµÂª∫Êñ∞ÂÄâ‰Ωç"""
        try:
            position = PositionInfo(
                position_id=f"POS_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{len(self.positions)}",
                symbol=trade_result.get('symbol', 'BTCTWD'),
                side=trade_result.get('side', 'buy'),
                quantity=trade_result.get('filled_quantity', 0),
                entry_price=trade_result.get('filled_price', 0),
                current_price=trade_result.get('filled_price', 0),
                entry_time=datetime.now(),
                ai_decision_id=ai_decision.get('decision_id')
            )
            
            # Ë®≠ÁΩÆÊ≠¢ÊêçÊ≠¢Áõà
            self._set_stop_loss_take_profit(position)
            
            # Ê∑ªÂä†Âà∞Ê¥ªË∫çÂÄâ‰Ωç
            self.positions.append(position)
            self.stats['total_positions'] += 1
            
            logger.info(f"üìà ÂâµÂª∫ÂÄâ‰Ωç: {position.position_id} - {position.side} {position.quantity:.6f} @ {position.entry_price:,.0f}")
            
            return position
            
        except Exception as e:
            logger.error(f"‚ùå ÂâµÂª∫ÂÄâ‰ΩçÂ§±Êïó: {e}")
            raise
    
    def update_positions(self, current_price: float) -> List[Dict[str, Any]]:
        """Êõ¥Êñ∞ÊâÄÊúâÂÄâ‰Ωç"""
        try:
            actions = []
            
            for position in self.positions.copy():
                # Êõ¥Êñ∞Áï∂ÂâçÂÉπÊ†ºÂíåÁõàËôß
                position.current_price = current_price
                self._update_position_pnl(position)
                
                # Ê™¢Êü•Ê≠¢ÊêçÊ≠¢ÁõàÊ¢ù‰ª∂
                action = self._check_exit_conditions(position)
                if action:
                    actions.append(action)
                
                # Êõ¥Êñ∞ËøΩËπ§Ê≠¢Êêç
                self._update_trailing_stop(position)
                
                # Ê™¢Êü•ÊúÄÂ§ßÊåÅÂÄâÊôÇÈñì
                if self._should_close_by_time(position):
                    actions.append({
                        'action': 'close_position',
                        'position': position,
                        'reason': 'max_holding_time',
                        'price': current_price
                    })
            
            return actions
            
        except Exception as e:
            logger.error(f"‚ùå Êõ¥Êñ∞ÂÄâ‰ΩçÂ§±Êïó: {e}")
            return []    

    def close_position(self, position: PositionInfo, close_price: float, 
                      reason: str = "manual") -> Dict[str, Any]:
        """ÈóúÈñâÂÄâ‰Ωç"""
        try:
            # Ë®àÁÆóÊúÄÁµÇÁõàËôß
            if position.side.lower() == 'buy':
                pnl = (close_price - position.entry_price) * position.quantity
            else:
                pnl = (position.entry_price - close_price) * position.quantity
            
            position.realized_pnl = pnl
            position.status = PositionStatus.CLOSED
            
            # ÂæûÊ¥ªË∫çÂÄâ‰ΩçÁßªÈô§
            if position in self.positions:
                self.positions.remove(position)
            
            # Ê∑ªÂä†Âà∞Â∑≤ÈóúÈñâÂÄâ‰Ωç
            self.closed_positions.append(position)
            
            # Êõ¥Êñ∞Áµ±Ë®à
            self._update_stats(position)
            
            close_result = {
                'position_id': position.position_id,
                'symbol': position.symbol,
                'side': position.side,
                'quantity': position.quantity,
                'entry_price': position.entry_price,
                'close_price': close_price,
                'pnl': pnl,
                'return_rate': pnl / (position.entry_price * position.quantity),
                'holding_time': datetime.now() - position.entry_time,
                'reason': reason
            }
            
            logger.info(f"üìâ ÈóúÈñâÂÄâ‰Ωç: {position.position_id} - ÁõàËôß: {pnl:+,.0f} TWD ({close_result['return_rate']:+.2%})")
            
            return close_result
            
        except Exception as e:
            logger.error(f"‚ùå ÈóúÈñâÂÄâ‰ΩçÂ§±Êïó: {e}")
            return {}
    
    def _set_stop_loss_take_profit(self, position: PositionInfo):
        """Ë®≠ÁΩÆÊ≠¢ÊêçÊ≠¢Áõà"""
        try:
            if position.side.lower() == 'buy':
                # Ë≤∑ÂÖ•ÂÄâ‰Ωç
                position.stop_loss = position.entry_price * (1 - self.config['default_stop_loss'])
                position.take_profit = position.entry_price * (1 + self.config['default_take_profit'])
            else:
                # Ë≥£Âá∫ÂÄâ‰Ωç
                position.stop_loss = position.entry_price * (1 + self.config['default_stop_loss'])
                position.take_profit = position.entry_price * (1 - self.config['default_take_profit'])
            
            # Ë®≠ÁΩÆËøΩËπ§Ê≠¢Êêç
            position.trailing_stop = position.stop_loss
            
        except Exception as e:
            logger.error(f"‚ùå Ë®≠ÁΩÆÊ≠¢ÊêçÊ≠¢ÁõàÂ§±Êïó: {e}")
    
    def _update_position_pnl(self, position: PositionInfo):
        """Êõ¥Êñ∞ÂÄâ‰ΩçÁõàËôß"""
        try:
            if position.side.lower() == 'buy':
                pnl = (position.current_price - position.entry_price) * position.quantity
            else:
                pnl = (position.entry_price - position.current_price) * position.quantity
            
            position.unrealized_pnl = pnl
            
            # Êõ¥Êñ∞ÊúÄÂ§ßÁõàÂà©ÂíåÊúÄÂ§ßËôßÊêç
            position.max_profit = max(position.max_profit, pnl)
            position.max_loss = min(position.max_loss, pnl)
            
        except Exception as e:
            logger.error(f"‚ùå Êõ¥Êñ∞ÂÄâ‰ΩçÁõàËôßÂ§±Êïó: {e}")
    
    def _check_exit_conditions(self, position: PositionInfo) -> Optional[Dict[str, Any]]:
        """Ê™¢Êü•ÈÄÄÂá∫Ê¢ù‰ª∂"""
        try:
            current_price = position.current_price
            
            # Ê™¢Êü•Ê≠¢Êêç
            if position.side.lower() == 'buy' and current_price <= position.stop_loss:
                return {
                    'action': 'close_position',
                    'position': position,
                    'reason': 'stop_loss',
                    'price': current_price
                }
            elif position.side.lower() == 'sell' and current_price >= position.stop_loss:
                return {
                    'action': 'close_position',
                    'position': position,
                    'reason': 'stop_loss',
                    'price': current_price
                }
            
            # Ê™¢Êü•Ê≠¢Áõà
            if position.side.lower() == 'buy' and current_price >= position.take_profit:
                return {
                    'action': 'close_position',
                    'position': position,
                    'reason': 'take_profit',
                    'price': current_price
                }
            elif position.side.lower() == 'sell' and current_price <= position.take_profit:
                return {
                    'action': 'close_position',
                    'position': position,
                    'reason': 'take_profit',
                    'price': current_price
                }
            
            return None
            
        except Exception as e:
            logger.error(f"‚ùå Ê™¢Êü•ÈÄÄÂá∫Ê¢ù‰ª∂Â§±Êïó: {e}")
            return None
    
    def _update_trailing_stop(self, position: PositionInfo):
        """Êõ¥Êñ∞ËøΩËπ§Ê≠¢Êêç"""
        try:
            if not position.trailing_stop:
                return
            
            current_price = position.current_price
            trailing_ratio = self.config['trailing_stop_ratio']
            
            if position.side.lower() == 'buy':
                # Ë≤∑ÂÖ•ÂÄâ‰ΩçÔºöÂÉπÊ†º‰∏äÊº≤ÊôÇÊèêÈ´òÊ≠¢ÊêçÁ∑ö
                new_trailing_stop = current_price * (1 - trailing_ratio)
                if new_trailing_stop > position.trailing_stop:
                    position.trailing_stop = new_trailing_stop
                    position.stop_loss = new_trailing_stop
            else:
                # Ë≥£Âá∫ÂÄâ‰ΩçÔºöÂÉπÊ†º‰∏ãË∑åÊôÇÈôç‰ΩéÊ≠¢ÊêçÁ∑ö
                new_trailing_stop = current_price * (1 + trailing_ratio)
                if new_trailing_stop < position.trailing_stop:
                    position.trailing_stop = new_trailing_stop
                    position.stop_loss = new_trailing_stop
            
        except Exception as e:
            logger.error(f"‚ùå Êõ¥Êñ∞ËøΩËπ§Ê≠¢ÊêçÂ§±Êïó: {e}")
    
    def _should_close_by_time(self, position: PositionInfo) -> bool:
        """Ê™¢Êü•ÊòØÂê¶ÊáâË©≤ÊåâÊôÇÈñìÈóúÈñâÂÄâ‰Ωç"""
        try:
            holding_time = datetime.now() - position.entry_time
            max_holding_time = timedelta(hours=self.config['max_holding_time'])
            
            return holding_time >= max_holding_time
            
        except Exception as e:
            logger.error(f"‚ùå Ê™¢Êü•ÊôÇÈñìÈóúÈñâÊ¢ù‰ª∂Â§±Êïó: {e}")
            return False
    
    def _update_stats(self, position: PositionInfo):
        """Êõ¥Êñ∞Áµ±Ë®à‰ø°ÊÅØ"""
        try:
            if position.realized_pnl > 0:
                self.stats['profitable_positions'] += 1
                self.stats['avg_profit'] = (
                    (self.stats['avg_profit'] * (self.stats['profitable_positions'] - 1) + position.realized_pnl) /
                    self.stats['profitable_positions']
                )
            else:
                self.stats['loss_positions'] += 1
                self.stats['avg_loss'] = (
                    (self.stats['avg_loss'] * (self.stats['loss_positions'] - 1) + position.realized_pnl) /
                    self.stats['loss_positions']
                )
            
            # Êõ¥Êñ∞ÂãùÁéá
            total_closed = self.stats['profitable_positions'] + self.stats['loss_positions']
            if total_closed > 0:
                self.stats['win_rate'] = self.stats['profitable_positions'] / total_closed
            
            # Êõ¥Êñ∞Á∏ΩÁõàËôß
            self.stats['total_pnl'] += position.realized_pnl
            
            # Êõ¥Êñ∞Âπ≥ÂùáÊåÅÂÄâÊôÇÈñì
            holding_time_hours = (datetime.now() - position.entry_time).total_seconds() / 3600
            self.stats['avg_holding_time'] = (
                (self.stats['avg_holding_time'] * (total_closed - 1) + holding_time_hours) /
                total_closed
            )
            
        except Exception as e:
            logger.error(f"‚ùå Êõ¥Êñ∞Áµ±Ë®à‰ø°ÊÅØÂ§±Êïó: {e}")
    
    def get_active_positions(self) -> List[Dict[str, Any]]:
        """Áç≤ÂèñÊ¥ªË∫çÂÄâ‰ΩçÊëòË¶Å"""
        try:
            positions_summary = []
            
            for position in self.positions:
                summary = {
                    'position_id': position.position_id,
                    'symbol': position.symbol,
                    'side': position.side,
                    'quantity': position.quantity,
                    'entry_price': position.entry_price,
                    'current_price': position.current_price,
                    'unrealized_pnl': position.unrealized_pnl,
                    'unrealized_return': position.unrealized_pnl / (position.entry_price * position.quantity),
                    'entry_time': position.entry_time,
                    'holding_duration': datetime.now() - position.entry_time,
                    'stop_loss': position.stop_loss,
                    'take_profit': position.take_profit,
                    'trailing_stop': position.trailing_stop,
                    'max_profit': position.max_profit,
                    'max_loss': position.max_loss
                }
                positions_summary.append(summary)
            
            return positions_summary
            
        except Exception as e:
            logger.error(f"‚ùå Áç≤ÂèñÊ¥ªË∫çÂÄâ‰ΩçÂ§±Êïó: {e}")
            return []
    
    def get_position_stats(self) -> Dict[str, Any]:
        """Áç≤ÂèñÂÄâ‰ΩçÁµ±Ë®à"""
        try:
            total_unrealized_pnl = sum(p.unrealized_pnl for p in self.positions)
            
            return {
                'active_positions': len(self.positions),
                'total_positions': self.stats['total_positions'],
                'profitable_positions': self.stats['profitable_positions'],
                'loss_positions': self.stats['loss_positions'],
                'win_rate': self.stats['win_rate'],
                'avg_profit': self.stats['avg_profit'],
                'avg_loss': self.stats['avg_loss'],
                'total_realized_pnl': self.stats['total_pnl'],
                'total_unrealized_pnl': total_unrealized_pnl,
                'total_pnl': self.stats['total_pnl'] + total_unrealized_pnl,
                'avg_holding_time_hours': self.stats['avg_holding_time']
            }
            
        except Exception as e:
            logger.error(f"‚ùå Áç≤ÂèñÂÄâ‰ΩçÁµ±Ë®àÂ§±Êïó: {e}")
            return {}
    
    def adjust_position_size(self, confidence: float, market_volatility: str) -> float:
        """Ê†πÊìö‰ø°ÂøÉÂ∫¶ÂíåÂ∏ÇÂ†¥Ê≥¢ÂãïË™øÊï¥ÂÄâ‰ΩçÂ§ßÂ∞è"""
        try:
            base_size = self.config['position_size_limit']
            
            # ‰ø°ÂøÉÂ∫¶Ë™øÊï¥
            confidence_multiplier = min(confidence / 0.6, 1.5)
            
            # Ê≥¢ÂãïÁéáË™øÊï¥
            volatility_multiplier = {
                '‰Ωé': 1.2,
                '‰∏≠': 1.0,
                'È´ò': 0.7
            }.get(market_volatility, 1.0)
            
            # Áï∂ÂâçÂÄâ‰ΩçÊï∏ÈáèË™øÊï¥
            position_count_multiplier = max(0.5, 1.0 - len(self.positions) * 0.1)
            
            adjusted_size = base_size * confidence_multiplier * volatility_multiplier * position_count_multiplier
            
            return min(adjusted_size, self.config['position_size_limit'])
            
        except Exception as e:
            logger.error(f"‚ùå Ë™øÊï¥ÂÄâ‰ΩçÂ§ßÂ∞èÂ§±Êïó: {e}")
            return self.config['position_size_limit']


# ÂâµÂª∫ÂÖ®Â±ÄÂÄâ‰ΩçÁÆ°ÁêÜÂô®ÂØ¶‰æã
def create_position_manager() -> PositionManager:
    """ÂâµÂª∫ÂÄâ‰ΩçÁÆ°ÁêÜÂô®ÂØ¶‰æã"""
    return PositionManager()


# Ê∏¨Ë©¶‰ª£Á¢º
if __name__ == "__main__":
    print("üß™ Ê∏¨Ë©¶ÂÄâ‰ΩçÁÆ°ÁêÜÂô®...")
    
    position_manager = create_position_manager()
    
    # Ê®°Êì¨‰∫§ÊòìÁµêÊûú
    trade_result = {
        'symbol': 'BTCTWD',
        'side': 'buy',
        'filled_quantity': 0.01,
        'filled_price': 1500000
    }
    
    # Ê®°Êì¨AIÊ±∫Á≠ñ
    ai_decision = {
        'decision_id': 'test_001',
        'confidence': 0.75
    }
    
    # ÂâµÂª∫ÂÄâ‰Ωç
    position = position_manager.create_position(trade_result, ai_decision)
    print(f"‚úÖ ÂâµÂª∫ÂÄâ‰Ωç: {position.position_id}")
    
    # Êõ¥Êñ∞ÂÄâ‰ΩçÔºàÊ®°Êì¨ÂÉπÊ†ºËÆäÂåñÔºâ
    actions = position_manager.update_positions(1520000)  # ÂÉπÊ†º‰∏äÊº≤
    print(f"üìä ÂÄâ‰ΩçÊõ¥Êñ∞Âãï‰Ωú: {len(actions)}")
    
    # Áç≤ÂèñÊ¥ªË∫çÂÄâ‰Ωç
    active_positions = position_manager.get_active_positions()
    print(f"üìà Ê¥ªË∫çÂÄâ‰Ωç: {len(active_positions)}")
    
    # Áç≤ÂèñÁµ±Ë®à‰ø°ÊÅØ
    stats = position_manager.get_position_stats()
    print(f"üìä ÂÄâ‰ΩçÁµ±Ë®à: {stats}")