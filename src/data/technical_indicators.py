#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ÂØ¶ÊôÇÊäÄË°ìÊåáÊ®ôË®àÁÆóÂô® - ÁÇ∫AIÊèê‰æõË±êÂØåÁöÑÊäÄË°ìÂàÜÊûêÊï∏Êìö
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Any
import logging
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)

class TechnicalIndicatorCalculator:
    """ÂØ¶ÊôÇÊäÄË°ìÊåáÊ®ôË®àÁÆóÂô®"""
    
    def __init__(self):
        """ÂàùÂßãÂåñÊäÄË°ìÊåáÊ®ôË®àÁÆóÂô®"""
        self.cache = {}  # Á∑©Â≠òË®àÁÆóÁµêÊûú
        logger.info("üìä ÊäÄË°ìÊåáÊ®ôË®àÁÆóÂô®ÂàùÂßãÂåñÂÆåÊàê")
    
    def calculate_comprehensive_indicators(self, klines_data: Dict[str, pd.DataFrame]) -> Dict[str, Any]:
        """
        Ë®àÁÆóÂÖ®Èù¢ÁöÑÊäÄË°ìÊåáÊ®ô
        
        Args:
            klines_data: ÂåÖÂê´‰∏çÂêåÊôÇÈñìÊ°ÜÊû∂ÁöÑKÁ∑öÊï∏Êìö
                - '1m': 1ÂàÜÈêòKÁ∑ö
                - '5m': 5ÂàÜÈêòKÁ∑ö
                - '1h': 1Â∞èÊôÇKÁ∑ö
        
        Returns:
            ÂåÖÂê´ÊâÄÊúâÊäÄË°ìÊåáÊ®ôÁöÑÂ≠óÂÖ∏
        """
        try:
            indicators = {}
            
            # Âü∫Êñº1ÂàÜÈêòÊï∏ÊìöÁöÑÁü≠ÊúüÊåáÊ®ô
            if '1m' in klines_data and len(klines_data['1m']) >= 20:
                short_term = self._calculate_short_term_indicators(klines_data['1m'])
                indicators.update({f"short_{k}": v for k, v in short_term.items()})
            
            # Âü∫Êñº5ÂàÜÈêòÊï∏ÊìöÁöÑ‰∏≠ÊúüÊåáÊ®ô
            if '5m' in klines_data and len(klines_data['5m']) >= 50:
                medium_term = self._calculate_medium_term_indicators(klines_data['5m'])
                indicators.update({f"medium_{k}": v for k, v in medium_term.items()})
            
            # Âü∫Êñº1Â∞èÊôÇÊï∏ÊìöÁöÑÈï∑ÊúüÊåáÊ®ô
            if '1h' in klines_data and len(klines_data['1h']) >= 24:
                long_term = self._calculate_long_term_indicators(klines_data['1h'])
                indicators.update({f"long_{k}": v for k, v in long_term.items()})
            
            # Ë∑®ÊôÇÈñìÊ°ÜÊû∂ÂàÜÊûê
            cross_timeframe = self._calculate_cross_timeframe_analysis(klines_data)
            indicators.update(cross_timeframe)
            
            # Â∏ÇÂ†¥ÊÉÖÁ∑íÊåáÊ®ô
            sentiment = self._calculate_market_sentiment(klines_data)
            indicators.update(sentiment)
            
            logger.info(f"‚úÖ Ë®àÁÆó‰∫Ü {len(indicators)} ÂÄãÊäÄË°ìÊåáÊ®ô")
            return indicators
            
        except Exception as e:
            logger.error(f"‚ùå ÊäÄË°ìÊåáÊ®ôË®àÁÆóÂ§±Êïó: {e}")
            return {}
    
    def _calculate_short_term_indicators(self, df: pd.DataFrame) -> Dict[str, Any]:
        """Ë®àÁÆóÁü≠ÊúüÊåáÊ®ôÔºà1ÂàÜÈêòÊï∏ÊìöÔºâ"""
        try:
            indicators = {}
            
            # Âø´ÈÄüÁßªÂãïÂπ≥Âùá
            indicators['ema_5'] = float(df['close'].ewm(span=5).mean().iloc[-1])
            indicators['ema_10'] = float(df['close'].ewm(span=10).mean().iloc[-1])
            indicators['sma_5'] = float(df['close'].rolling(5).mean().iloc[-1])
            indicators['sma_10'] = float(df['close'].rolling(10).mean().iloc[-1])
            
            # ÂÉπÊ†ºÂãïÈáè
            indicators['momentum_5'] = float((df['close'].iloc[-1] - df['close'].iloc[-6]) / df['close'].iloc[-6] * 100)
            indicators['momentum_10'] = float((df['close'].iloc[-1] - df['close'].iloc[-11]) / df['close'].iloc[-11] * 100)
            
            # Êàê‰∫§ÈáèÊåáÊ®ô
            indicators['volume_sma'] = float(df['volume'].rolling(10).mean().iloc[-1])
            indicators['volume_ratio'] = float(df['volume'].iloc[-1] / indicators['volume_sma'])
            
            # ÂÉπÊ†ºÊ≥¢Âãï
            returns = df['close'].pct_change()
            indicators['volatility_1m'] = float(returns.rolling(10).std() * np.sqrt(1440))  # Êó•ÂåñÊ≥¢ÂãïÁéá
            
            # ÊîØÊíêÈòªÂäõ
            recent_high = float(df['high'].rolling(10).max().iloc[-1])
            recent_low = float(df['low'].rolling(10).min().iloc[-1])
            current_price = float(df['close'].iloc[-1])
            
            indicators['resistance_level'] = recent_high
            indicators['support_level'] = recent_low
            indicators['price_position'] = (current_price - recent_low) / (recent_high - recent_low) if recent_high != recent_low else 0.5
            
            return indicators
            
        except Exception as e:
            logger.error(f"‚ùå Áü≠ÊúüÊåáÊ®ôË®àÁÆóÂ§±Êïó: {e}")
            return {}
    
    def _calculate_medium_term_indicators(self, df: pd.DataFrame) -> Dict[str, Any]:
        """Ë®àÁÆó‰∏≠ÊúüÊåáÊ®ôÔºà5ÂàÜÈêòÊï∏ÊìöÔºâ"""
        try:
            indicators = {}
            
            # RSI
            if len(df) >= 14:
                delta = df['close'].diff()
                gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
                loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
                rs = gain / loss
                rsi = 100 - (100 / (1 + rs))
                indicators['rsi'] = float(rsi.iloc[-1]) if not pd.isna(rsi.iloc[-1]) else 50
                
                # RSIË∂®Âã¢
                rsi_trend = rsi.diff().iloc[-1]
                indicators['rsi_trend'] = "‰∏äÂçá" if rsi_trend > 0 else "‰∏ãÈôç" if rsi_trend < 0 else "Âπ≥Á©©"
            
            # MACD
            if len(df) >= 26:
                ema_12 = df['close'].ewm(span=12).mean()
                ema_26 = df['close'].ewm(span=26).mean()
                macd_line = ema_12 - ema_26
                signal_line = macd_line.ewm(span=9).mean()
                histogram = macd_line - signal_line
                
                indicators['macd'] = float(macd_line.iloc[-1])
                indicators['macd_signal'] = float(signal_line.iloc[-1])
                indicators['macd_histogram'] = float(histogram.iloc[-1])
                
                # MACD‰ø°Ëôü
                if macd_line.iloc[-1] > signal_line.iloc[-1]:
                    if macd_line.iloc[-2] <= signal_line.iloc[-2]:
                        indicators['macd_signal_type'] = "ÈáëÂèâ"
                    else:
                        indicators['macd_signal_type'] = "Â§öÈ†≠"
                else:
                    if macd_line.iloc[-2] >= signal_line.iloc[-2]:
                        indicators['macd_signal_type'] = "Ê≠ªÂèâ"
                    else:
                        indicators['macd_signal_type'] = "Á©∫È†≠"
            
            # Â∏ÉÊûóÂ∏∂
            if len(df) >= 20:
                sma_20 = df['close'].rolling(20).mean()
                std_20 = df['close'].rolling(20).std()
                upper_band = sma_20 + (std_20 * 2)
                lower_band = sma_20 - (std_20 * 2)
                
                current_price = df['close'].iloc[-1]
                indicators['bb_upper'] = float(upper_band.iloc[-1])
                indicators['bb_middle'] = float(sma_20.iloc[-1])
                indicators['bb_lower'] = float(lower_band.iloc[-1])
                indicators['bb_position'] = float((current_price - lower_band.iloc[-1]) / (upper_band.iloc[-1] - lower_band.iloc[-1]))
                
                # Â∏ÉÊûóÂ∏∂‰ø°Ëôü
                if current_price > upper_band.iloc[-1]:
                    indicators['bb_signal'] = "Ë∂ÖË≤∑"
                elif current_price < lower_band.iloc[-1]:
                    indicators['bb_signal'] = "Ë∂ÖË≥£"
                else:
                    indicators['bb_signal'] = "Ê≠£Â∏∏"
            
            # KDJÊåáÊ®ô
            if len(df) >= 9:
                low_9 = df['low'].rolling(9).min()
                high_9 = df['high'].rolling(9).max()
                rsv = (df['close'] - low_9) / (high_9 - low_9) * 100
                k = rsv.ewm(com=2).mean()
                d = k.ewm(com=2).mean()
                j = 3 * k - 2 * d
                
                indicators['kdj_k'] = float(k.iloc[-1])
                indicators['kdj_d'] = float(d.iloc[-1])
                indicators['kdj_j'] = float(j.iloc[-1])
                
                # KDJ‰ø°Ëôü
                if k.iloc[-1] > d.iloc[-1] and k.iloc[-2] <= d.iloc[-2]:
                    indicators['kdj_signal'] = "ÈáëÂèâ"
                elif k.iloc[-1] < d.iloc[-1] and k.iloc[-2] >= d.iloc[-2]:
                    indicators['kdj_signal'] = "Ê≠ªÂèâ"
                else:
                    indicators['kdj_signal'] = "ÊåÅÁ∫å"
            
            return indicators
            
        except Exception as e:
            logger.error(f"‚ùå ‰∏≠ÊúüÊåáÊ®ôË®àÁÆóÂ§±Êïó: {e}")
            return {}
    
    def _calculate_long_term_indicators(self, df: pd.DataFrame) -> Dict[str, Any]:
        """Ë®àÁÆóÈï∑ÊúüÊåáÊ®ôÔºà1Â∞èÊôÇÊï∏ÊìöÔºâ"""
        try:
            indicators = {}
            
            # Èï∑ÊúüÁßªÂãïÂπ≥Âùá
            if len(df) >= 20:
                indicators['sma_20'] = float(df['close'].rolling(20).mean().iloc[-1])
                indicators['ema_20'] = float(df['close'].ewm(span=20).mean().iloc[-1])
                
                # Ë∂®Âã¢Âà§Êñ∑
                current_price = df['close'].iloc[-1]
                if current_price > indicators['sma_20']:
                    indicators['trend_sma20'] = "‰∏äÂçá"
                else:
                    indicators['trend_sma20'] = "‰∏ãÈôç"
            
            # ÂÉπÊ†ºÈÄöÈÅì
            if len(df) >= 20:
                high_20 = df['high'].rolling(20).max()
                low_20 = df['low'].rolling(20).min()
                
                indicators['channel_high'] = float(high_20.iloc[-1])
                indicators['channel_low'] = float(low_20.iloc[-1])
                indicators['channel_position'] = float((df['close'].iloc[-1] - low_20.iloc[-1]) / (high_20.iloc[-1] - low_20.iloc[-1]))
            
            # Êàê‰∫§ÈáèË∂®Âã¢
            if len(df) >= 10:
                volume_trend = np.polyfit(range(10), df['volume'].iloc[-10:].values, 1)[0]
                indicators['volume_trend_slope'] = float(volume_trend)
                indicators['volume_trend'] = "Â¢ûÂä†" if volume_trend > 0 else "Ê∏õÂ∞ë"
            
            # Ê≥¢ÂãïÁéáÂàÜÊûê
            returns = df['close'].pct_change().dropna()
            if len(returns) >= 10:
                indicators['volatility_1h'] = float(returns.rolling(10).std() * np.sqrt(24))
                indicators['volatility_level'] = "È´ò" if indicators['volatility_1h'] > 0.05 else "‰∏≠" if indicators['volatility_1h'] > 0.02 else "‰Ωé"
            
            return indicators
            
        except Exception as e:
            logger.error(f"‚ùå Èï∑ÊúüÊåáÊ®ôË®àÁÆóÂ§±Êïó: {e}")
            return {}
    
    def _calculate_cross_timeframe_analysis(self, klines_data: Dict[str, pd.DataFrame]) -> Dict[str, Any]:
        """Ë∑®ÊôÇÈñìÊ°ÜÊû∂ÂàÜÊûê"""
        try:
            analysis = {}
            
            # Â§öÊôÇÈñìÊ°ÜÊû∂Ë∂®Âã¢‰∏ÄËá¥ÊÄß
            trends = []
            
            if '1m' in klines_data and len(klines_data['1m']) >= 10:
                short_trend = self._get_price_trend(klines_data['1m'], 10)
                trends.append(short_trend)
                analysis['trend_1m'] = short_trend
            
            if '5m' in klines_data and len(klines_data['5m']) >= 10:
                medium_trend = self._get_price_trend(klines_data['5m'], 10)
                trends.append(medium_trend)
                analysis['trend_5m'] = medium_trend
            
            if '1h' in klines_data and len(klines_data['1h']) >= 10:
                long_trend = self._get_price_trend(klines_data['1h'], 10)
                trends.append(long_trend)
                analysis['trend_1h'] = long_trend
            
            # Ë∂®Âã¢‰∏ÄËá¥ÊÄßË©ïÂàÜ
            if trends:
                up_count = trends.count("‰∏äÂçá")
                down_count = trends.count("‰∏ãÈôç")
                total = len(trends)
                
                analysis['trend_consistency'] = max(up_count, down_count) / total
                analysis['dominant_trend'] = "‰∏äÂçá" if up_count > down_count else "‰∏ãÈôç" if down_count > up_count else "ÈúáÁõ™"
            
            return analysis
            
        except Exception as e:
            logger.error(f"‚ùå Ë∑®ÊôÇÈñìÊ°ÜÊû∂ÂàÜÊûêÂ§±Êïó: {e}")
            return {}
    
    def _calculate_market_sentiment(self, klines_data: Dict[str, pd.DataFrame]) -> Dict[str, Any]:
        """Ë®àÁÆóÂ∏ÇÂ†¥ÊÉÖÁ∑íÊåáÊ®ô"""
        try:
            sentiment = {}
            
            # Âü∫Êñº5ÂàÜÈêòÊï∏ÊìöÁöÑÊÉÖÁ∑íÂàÜÊûê
            if '5m' in klines_data and len(klines_data['5m']) >= 20:
                df = klines_data['5m']
                
                # Â§öÁ©∫ÂäõÈáèÂ∞çÊØî
                green_candles = (df['close'] > df['open']).sum()
                red_candles = (df['close'] < df['open']).sum()
                total_candles = len(df)
                
                sentiment['bullish_ratio'] = green_candles / total_candles
                sentiment['bearish_ratio'] = red_candles / total_candles
                
                # Â∏ÇÂ†¥ÊÉÖÁ∑íË©ïÁ¥ö
                if sentiment['bullish_ratio'] > 0.6:
                    sentiment['market_mood'] = "Ê®ÇËßÄ"
                elif sentiment['bearish_ratio'] > 0.6:
                    sentiment['market_mood'] = "ÊÇ≤ËßÄ"
                else:
                    sentiment['market_mood'] = "‰∏≠ÊÄß"
                
                # Êàê‰∫§ÈáèÊÉÖÁ∑í
                recent_volume = df['volume'].iloc[-5:].mean()
                avg_volume = df['volume'].mean()
                sentiment['volume_sentiment'] = "Ê¥ªË∫ç" if recent_volume > avg_volume * 1.2 else "‰ΩéËø∑" if recent_volume < avg_volume * 0.8 else "Ê≠£Â∏∏"
            
            return sentiment
            
        except Exception as e:
            logger.error(f"‚ùå Â∏ÇÂ†¥ÊÉÖÁ∑íË®àÁÆóÂ§±Êïó: {e}")
            return {}
    
    def _get_price_trend(self, df: pd.DataFrame, periods: int) -> str:
        """Áç≤ÂèñÂÉπÊ†ºË∂®Âã¢"""
        try:
            if len(df) < periods:
                return "‰∏çÊòé"
            
            prices = df['close'].iloc[-periods:].values
            trend_slope = np.polyfit(range(periods), prices, 1)[0]
            
            if trend_slope > 0:
                return "‰∏äÂçá"
            elif trend_slope < 0:
                return "‰∏ãÈôç"
            else:
                return "ÈúáÁõ™"
                
        except Exception:
            return "‰∏çÊòé"
    
    def format_indicators_for_ai(self, indicators: Dict[str, Any]) -> str:
        """Â∞áÊäÄË°ìÊåáÊ®ôÊ†ºÂºèÂåñÁÇ∫AIÂèãÂ•ΩÁöÑÊ†ºÂºè"""
        try:
            if not indicators:
                return "ÊäÄË°ìÊåáÊ®ôÊï∏Êìö‰∏çÂèØÁî®"
            
            formatted = f"""
üìä ÊäÄË°ìÊåáÊ®ôÂÖ®Èù¢ÂàÜÊûê

üî• Áü≠ÊúüÊåáÊ®ô (1ÂàÜÈêò):
- EMA5: {indicators.get('short_ema_5', 'N/A'):,.0f}
- EMA10: {indicators.get('short_ema_10', 'N/A'):,.0f}
- 5ÂàÜÈêòÂãïÈáè: {indicators.get('short_momentum_5', 0):+.2f}%
- Êàê‰∫§ÈáèÊØîÁéá: {indicators.get('short_volume_ratio', 1.0):.2f}x
- ÂÉπÊ†º‰ΩçÁΩÆ: {indicators.get('short_price_position', 0.5):.1%}

üìà ‰∏≠ÊúüÊåáÊ®ô (5ÂàÜÈêò):
- RSI: {indicators.get('medium_rsi', 50):.1f} ({indicators.get('medium_rsi_trend', 'Âπ≥Á©©')})
- MACD: {indicators.get('medium_macd_signal_type', '‰∏≠ÊÄß')}
- Â∏ÉÊûóÂ∏∂: {indicators.get('medium_bb_signal', 'Ê≠£Â∏∏')} (‰ΩçÁΩÆ: {indicators.get('medium_bb_position', 0.5):.1%})
- KDJ: {indicators.get('medium_kdj_signal', 'ÊåÅÁ∫å')} (K:{indicators.get('medium_kdj_k', 50):.1f})

üìä Èï∑ÊúüÊåáÊ®ô (1Â∞èÊôÇ):
- SMA20Ë∂®Âã¢: {indicators.get('long_trend_sma20', '‰∏çÊòé')}
- ÈÄöÈÅì‰ΩçÁΩÆ: {indicators.get('long_channel_position', 0.5):.1%}
- Êàê‰∫§ÈáèË∂®Âã¢: {indicators.get('long_volume_trend', 'Á©©ÂÆö')}
- Ê≥¢ÂãïÁéá: {indicators.get('long_volatility_level', '‰∏≠Á≠â')}

üéØ Ë∑®ÊôÇÈñìÊ°ÜÊû∂ÂàÜÊûê:
- ‰∏ªÂ∞éË∂®Âã¢: {indicators.get('dominant_trend', 'ÈúáÁõ™')}
- Ë∂®Âã¢‰∏ÄËá¥ÊÄß: {indicators.get('trend_consistency', 0.5):.1%}
- 1ÂàÜÈêòË∂®Âã¢: {indicators.get('trend_1m', '‰∏çÊòé')}
- 5ÂàÜÈêòË∂®Âã¢: {indicators.get('trend_5m', '‰∏çÊòé')}
- 1Â∞èÊôÇË∂®Âã¢: {indicators.get('trend_1h', '‰∏çÊòé')}

üí≠ Â∏ÇÂ†¥ÊÉÖÁ∑í:
- Â∏ÇÂ†¥ÊÉÖÁ∑í: {indicators.get('market_mood', '‰∏≠ÊÄß')}
- Â§öÈ†≠ÊØî‰æã: {indicators.get('bullish_ratio', 0.5):.1%}
- Á©∫È†≠ÊØî‰æã: {indicators.get('bearish_ratio', 0.5):.1%}
- Êàê‰∫§ÈáèÊÉÖÁ∑í: {indicators.get('volume_sentiment', 'Ê≠£Â∏∏')}
"""
            
            return formatted.strip()
            
        except Exception as e:
            logger.error(f"‚ùå ÊåáÊ®ôÊ†ºÂºèÂåñÂ§±Êïó: {e}")
            return "ÊäÄË°ìÊåáÊ®ôÊ†ºÂºèÂåñÂ§±Êïó"


# ÂâµÂª∫ÂÖ®Â±ÄÊäÄË°ìÊåáÊ®ôË®àÁÆóÂô®ÂØ¶‰æã
def create_technical_calculator() -> TechnicalIndicatorCalculator:
    """ÂâµÂª∫ÊäÄË°ìÊåáÊ®ôË®àÁÆóÂô®ÂØ¶‰æã"""
    return TechnicalIndicatorCalculator()


# Ê∏¨Ë©¶‰ª£Á¢º
if __name__ == "__main__":
    print("üß™ Ê∏¨Ë©¶ÊäÄË°ìÊåáÊ®ôË®àÁÆóÂô®...")
    
    # ÂâµÂª∫Ê∏¨Ë©¶Êï∏Êìö
    import pandas as pd
    from datetime import datetime, timedelta
    
    # Ê®°Êì¨KÁ∑öÊï∏Êìö
    dates = pd.date_range(start=datetime.now() - timedelta(hours=2), periods=120, freq='1min')
    test_data = {
        '1m': pd.DataFrame({
            'timestamp': dates,
            'open': np.random.normal(1500000, 10000, 120),
            'high': np.random.normal(1505000, 10000, 120),
            'low': np.random.normal(1495000, 10000, 120),
            'close': np.random.normal(1500000, 10000, 120),
            'volume': np.random.normal(1000, 200, 120)
        }),
        '5m': pd.DataFrame({
            'timestamp': pd.date_range(start=datetime.now() - timedelta(hours=4), periods=48, freq='5min'),
            'open': np.random.normal(1500000, 15000, 48),
            'high': np.random.normal(1510000, 15000, 48),
            'low': np.random.normal(1490000, 15000, 48),
            'close': np.random.normal(1500000, 15000, 48),
            'volume': np.random.normal(5000, 1000, 48)
        }),
        '1h': pd.DataFrame({
            'timestamp': pd.date_range(start=datetime.now() - timedelta(hours=24), periods=24, freq='1h'),
            'open': np.random.normal(1500000, 25000, 24),
            'high': np.random.normal(1520000, 25000, 24),
            'low': np.random.normal(1480000, 25000, 24),
            'close': np.random.normal(1500000, 25000, 24),
            'volume': np.random.normal(20000, 5000, 24)
        })
    }
    
    # Ê∏¨Ë©¶Ë®àÁÆóÂô®
    calculator = create_technical_calculator()
    indicators = calculator.calculate_comprehensive_indicators(test_data)
    
    print(f"‚úÖ Ë®àÁÆó‰∫Ü {len(indicators)} ÂÄãÊäÄË°ìÊåáÊ®ô")
    
    # Ê†ºÂºèÂåñÈ°ØÁ§∫
    formatted = calculator.format_indicators_for_ai(indicators)
    print(formatted)